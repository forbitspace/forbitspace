"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createHook = createHook;
exports.createMemoizedSelector = void 0;

var _react = require("react");

var _context = require("../context");

var _memoize = _interopRequireDefault(require("../utils/memoize"));

var _shallowEqual = _interopRequireDefault(require("../utils/shallow-equal"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var EMPTY_SELECTOR = function EMPTY_SELECTOR() {
  return undefined;
};

var DEFAULT_SELECTOR = function DEFAULT_SELECTOR(state) {
  return state;
}; // As we want to subscribe ASAP and useEffect happens on next tick, but
// React currently throws a warning when using useLayoutEffect on the server


var useIsomorphicLayoutEffect = typeof window !== 'undefined' ? _react.useLayoutEffect : _react.useEffect; // We memoize both the input and the output
// so if input args are shallow equal we do not recompute the selector
// and also when we do, check if output is shallow equal to prevent children update

var createMemoizedSelector = function createMemoizedSelector(selector) {
  var memoSelector = (0, _memoize["default"])(selector);
  var lastResult;
  return function (currentState, hookArg) {
    var result = memoSelector(currentState, hookArg);

    if (!(0, _shallowEqual["default"])(result, lastResult)) {
      lastResult = result;
    }

    return lastResult;
  };
};

exports.createMemoizedSelector = createMemoizedSelector;

function createHook(Store) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      selector = _ref.selector;

  return function useSweetState(propsArg) {
    var _useContext = (0, _react.useContext)(_context.Context),
        getStore = _useContext.getStore;

    var _getStore = getStore(Store),
        storeState = _getStore.storeState,
        actions = _getStore.actions; // If selector is not null, create a ref to the memoized version of it
    // Otherwise always return same value, as we ignore state


    var stateSelector = selector ? // eslint-disable-next-line react-hooks/rules-of-hooks
    (0, _react.useMemo)(function () {
      return createMemoizedSelector(selector);
    }, []) : selector === null ? EMPTY_SELECTOR : DEFAULT_SELECTOR; // At every render we get fresh state and using recent propsArg
    // we calculate the current value, to be used immediately

    var currentState = stateSelector(storeState.getState(), propsArg);
    (0, _react.useDebugValue)(currentState);
    var triggerUpdate = (0, _react.useState)(currentState)[1];
    var propsRef = (0, _react.useRef)(propsArg);
    propsRef.current = propsArg;
    useIsomorphicLayoutEffect(function () {
      var subscription = {};
      var prevState;

      var onUpdate = function onUpdate(updatedState, updatedStoreState) {
        // if already unmounted ignore the update
        if (!subscription) return; // if scope changed, force a re-render to trigger new subscription

        if (updatedStoreState !== storeState) return triggerUpdate({}); // if selector null we bail out from normal state updates

        if (stateSelector === EMPTY_SELECTOR) return;
        var nextState = stateSelector(updatedState, propsRef.current);

        if (nextState !== prevState) {
          triggerUpdate(nextState);
          prevState = nextState;
        }
      };

      subscription.unsubscribe = storeState.subscribe(onUpdate); // Because we're subscribing in a passive effect,
      // it's possible that an update has occurred between render and effect

      onUpdate(storeState.getState(), storeState);
      return function () {
        // On component unmount we unsubscribe to storeState updates
        subscription.unsubscribe();
        subscription = null;
      };
    }, [storeState]);
    return [currentState, actions];
  };
}