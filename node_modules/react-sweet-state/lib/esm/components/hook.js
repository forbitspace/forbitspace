import { useState, useLayoutEffect, useEffect, useRef, useMemo, useContext, useDebugValue } from 'react';
import { Context } from '../context';
import memoize from '../utils/memoize';
import shallowEqual from '../utils/shallow-equal';

var EMPTY_SELECTOR = function EMPTY_SELECTOR() {
  return undefined;
};

var DEFAULT_SELECTOR = function DEFAULT_SELECTOR(state) {
  return state;
}; // As we want to subscribe ASAP and useEffect happens on next tick, but
// React currently throws a warning when using useLayoutEffect on the server


var useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect; // We memoize both the input and the output
// so if input args are shallow equal we do not recompute the selector
// and also when we do, check if output is shallow equal to prevent children update

export var createMemoizedSelector = function createMemoizedSelector(selector) {
  var memoSelector = memoize(selector);
  var lastResult;
  return function (currentState, hookArg) {
    var result = memoSelector(currentState, hookArg);

    if (!shallowEqual(result, lastResult)) {
      lastResult = result;
    }

    return lastResult;
  };
};
export function createHook(Store) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      selector = _ref.selector;

  return function useSweetState(propsArg) {
    var _useContext = useContext(Context),
        getStore = _useContext.getStore;

    var _getStore = getStore(Store),
        storeState = _getStore.storeState,
        actions = _getStore.actions; // If selector is not null, create a ref to the memoized version of it
    // Otherwise always return same value, as we ignore state


    var stateSelector = selector ? // eslint-disable-next-line react-hooks/rules-of-hooks
    useMemo(function () {
      return createMemoizedSelector(selector);
    }, []) : selector === null ? EMPTY_SELECTOR : DEFAULT_SELECTOR; // At every render we get fresh state and using recent propsArg
    // we calculate the current value, to be used immediately

    var currentState = stateSelector(storeState.getState(), propsArg);
    useDebugValue(currentState);
    var triggerUpdate = useState(currentState)[1];
    var propsRef = useRef(propsArg);
    propsRef.current = propsArg;
    useIsomorphicLayoutEffect(function () {
      var subscription = {};
      var prevState;

      var onUpdate = function onUpdate(updatedState, updatedStoreState) {
        // if already unmounted ignore the update
        if (!subscription) return; // if scope changed, force a re-render to trigger new subscription

        if (updatedStoreState !== storeState) return triggerUpdate({}); // if selector null we bail out from normal state updates

        if (stateSelector === EMPTY_SELECTOR) return;
        var nextState = stateSelector(updatedState, propsRef.current);

        if (nextState !== prevState) {
          triggerUpdate(nextState);
          prevState = nextState;
        }
      };

      subscription.unsubscribe = storeState.subscribe(onUpdate); // Because we're subscribing in a passive effect,
      // it's possible that an update has occurred between render and effect

      onUpdate(storeState.getState(), storeState);
      return function () {
        // On component unmount we unsubscribe to storeState updates
        subscription.unsubscribe();
        subscription = null;
      };
    }, [storeState]);
    return [currentState, actions];
  };
}